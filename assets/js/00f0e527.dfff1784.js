"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[834],{724:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>c});var a=n(2540),s=n(3023);const r={sidebar_position:1},i="Standard Methods",o={id:"api/standard",title:"Standard Methods",description:"This page documents the standard methods available when using a history adapter instance.",source:"@site/docs/api/standard.md",sourceDirName:"api",slug:"/api/standard",permalink:"/history-adapter/api/standard",draft:!1,unlisted:!1,editUrl:"https://github.com/EskiMojo14/history-adapter/tree/main/website/docs/api/standard.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docs",previous:{title:"API",permalink:"/history-adapter/category/api"},next:{title:"Redux Methods",permalink:"/history-adapter/api/redux"}},d={},c=[{value:"<code>getInitialState</code>",id:"getinitialstate",level:2},{value:"<code>undoable</code>",id:"undoable",level:2},{value:"Extracting whether a change is undoable",id:"extracting-whether-a-change-is-undoable",level:3},{value:"Nested history state",id:"nested-history-state",level:3},{value:"<code>undo</code>, <code>redo</code>, <code>jump</code>",id:"undo-redo-jump",level:2},{value:"<code>clearHistory</code>",id:"clearhistory",level:2},{value:"Pausing history",id:"pausing-history",level:2}];function l(e){const t={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"standard-methods",children:"Standard Methods"}),"\n",(0,a.jsx)(t.p,{children:"This page documents the standard methods available when using a history adapter instance."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'import { createHistoryAdapter } from "history-adapter";\n\ninterface CounterState {\n  value: number;\n}\n\nconst counterAdapter = createHistoryAdapter<CounterState>({ limit: 10 });\n'})}),"\n",(0,a.jsx)(t.h2,{id:"getinitialstate",children:(0,a.jsx)(t.code,{children:"getInitialState"})}),"\n",(0,a.jsx)(t.p,{children:'Receives an initial state value and returns a "history state" shape.'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const initialState = counterAdapter.getInitialState({ value: 0 });\n\n// { past: [], present: { value: 0 }, future: [], paused: false }\n"})}),"\n",(0,a.jsxs)(t.admonition,{type:"tip",children:[(0,a.jsxs)(t.p,{children:["A standalone version of this method is available as ",(0,a.jsx)(t.code,{children:"getInitialState"}),"."]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:'import { getInitialState } from "history-adapter";\n\nconst initialState = getInitialState({ value: 0 });\n'})})]}),"\n",(0,a.jsx)(t.h2,{id:"undoable",children:(0,a.jsx)(t.code,{children:"undoable"})}),"\n",(0,a.jsx)(t.p,{children:"Wraps an immer recipe to automatically manage undo and redo state. Because immer wraps the state in a draft, you can safely mutate the state directly."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const increment = counterAdapter.undoable((draft) => {\n  draft.value += 1;\n});\n\nconst initialState = counterAdapter.getInitialState({ value: 0 });\n\nconst nextState = increment(initialState);\n\n// { past: [{ value: 0 }], present: { value: 1 }, future: [], paused: false }\n"})}),"\n",(0,a.jsxs)(t.admonition,{title:"State operators",type:"tip",children:[(0,a.jsxs)(t.p,{children:["All of the methods to update state (",(0,a.jsx)(t.code,{children:"undo"}),", ",(0,a.jsx)(t.code,{children:"redo"}),", etc.) will act mutably when passed a draft, otherwise return a new state. The same applies to the function returned by ",(0,a.jsx)(t.code,{children:"undoable"}),"."]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"console.log(initialState.present.value, nextState.present.value); // 0, 1\n\nconst withDraft = produce(initialState, (draft) => {\n  increment(draft);\n});\n\nconsole.log(initialState.present.value, withDraft.present.value); // 0, 1\n"})})]}),"\n",(0,a.jsx)(t.h3,{id:"extracting-whether-a-change-is-undoable",children:"Extracting whether a change is undoable"}),"\n",(0,a.jsxs)(t.p,{children:["By default, a change is assumed to be undoable, and is added to the history stack. To have finer control over this behaviour, you can pass an ",(0,a.jsx)(t.code,{children:"isUndoable"})," function as part of the optional configuration object. This function receives the same arguments as the recipe, and should return a boolean (or ",(0,a.jsx)(t.code,{children:"undefined"}),", in which case the change is assumed to be undoable)."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const incrementBy = counterAdapter.undoable(\n  (draft, amount: number) => {\n    draft.value += amount;\n  },\n  {\n    // don't bother adding to history if the amount is zero\n    // highlight-next-line\n    isUndoable: (amount) => amount !== 0,\n  },\n);\n"})}),"\n",(0,a.jsx)(t.h3,{id:"nested-history-state",children:"Nested history state"}),"\n",(0,a.jsxs)(t.p,{children:["Sometimes the state you want to manage is nested within a larger object. In this case, you can pass a ",(0,a.jsx)(t.code,{children:"selectHistoryState"})," function to ",(0,a.jsx)(t.code,{children:"undoable"})," to extract the relevant state."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"interface RootState {\n  counter: HistoryState<CounterState>;\n}\n\nconst increment = counterAdapter.undoable(\n  (draft) => {\n    draft.value += 1;\n  },\n  {\n    // highlight-next-line\n    selectHistoryState: (state: RootState) => state.counter,\n  },\n);\n\nconst initialState = { counter: counterAdapter.getInitialState({ value: 0 }) };\n\nconst nextState = increment(initialState);\n\n// { counter: { past: [{ value: 0 }], present: { value: 1 }, future: [], paused: false } }\n"})}),"\n",(0,a.jsx)(t.p,{children:"It should be a function that receives the wider state object and returns the history state object."}),"\n",(0,a.jsxs)(t.h2,{id:"undo-redo-jump",children:[(0,a.jsx)(t.code,{children:"undo"}),", ",(0,a.jsx)(t.code,{children:"redo"}),", ",(0,a.jsx)(t.code,{children:"jump"})]}),"\n",(0,a.jsx)(t.p,{children:"These methods allow you to navigate the history stack."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const undoneState = counterAdapter.undo(nextState);\n// { past: [], present: { value: 0 }, future: [{ value: 1 }], paused: false }\n\nconst redoneState = counterAdapter.redo(undoneState);\n// { past: [{ value: 0 }], present: { value: 1 }, future: [], paused: false }\n\nconst jumpedState = counterAdapter.jump(redoneState, -1); // negative numbers move back, positive move forward\n// { past: [], present: { value: 0 }, future: [{ value: 1 }], paused: false }\n"})}),"\n",(0,a.jsx)(t.h2,{id:"clearhistory",children:(0,a.jsx)(t.code,{children:"clearHistory"})}),"\n",(0,a.jsx)(t.p,{children:"Clears the history stack, while preserving the present state."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const clearedState = counterAdapter.clearHistory(nextState);\n// { past: [], present: { value: 1 }, future: [], paused: false }\n"})}),"\n",(0,a.jsx)(t.h2,{id:"pausing-history",children:"Pausing history"}),"\n",(0,a.jsxs)(t.p,{children:["To pause recording of history, you can set the ",(0,a.jsx)(t.code,{children:"paused"})," flag in state to ",(0,a.jsx)(t.code,{children:"true"})," - ",(0,a.jsx)(t.code,{children:"pause"})," and ",(0,a.jsx)(t.code,{children:"resume"})," methods are provided for this purpose."]}),"\n",(0,a.jsx)(t.p,{children:"Changes made while paused will not be added to the history stack, but will still update the present state."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-ts",children:"const pausedState = counterAdapter.pause(nextState);\n// { past: [{ value: 0 }], present: { value: 1 }, future: [], paused: true }\n\nconst whilePaused = increment(pausedState);\n// { past: [{ value: 0 }], present: { value: 2 }, future: [], paused: true }\n\nconst resumedState = counterAdapter.resume(whilePaused);\n// { past: [{ value: 0 }], present: { value: 2 }, future: [], paused: false }\n\nconst undone = counterAdapter.undo(resumedState);\n// { past: [], present: { value: 0 }, future: [{ value: 2 }], paused: false }\n"})})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},3023:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var a=n(3696);const s={},r=a.createContext(s);function i(e){const t=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:t},e.children)}}}]);