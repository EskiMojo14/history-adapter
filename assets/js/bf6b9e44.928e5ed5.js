"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[113],{6463:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var r=n(2540),s=n(3023);const a={sidebar_position:3},i="Creating a Custom Adapter",o={id:"custom",title:"Creating a Custom Adapter",description:"While createHistoryAdapter and createPatchHistoryAdapter cover the most common ways to track history, you may want to create your history entries in a different format. This guide will show you how to create a custom adapter.",source:"@site/docs/custom.md",sourceDirName:".",slug:"/custom",permalink:"/history-adapter/custom",draft:!1,unlisted:!1,editUrl:"https://github.com/EskiMojo14/history-adapter/tree/main/website/docs/custom.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docs",previous:{title:"Redux Methods",permalink:"/history-adapter/api/redux"}},c={},d=[{value:"<code>buildCreateHistoryAdapter</code>",id:"buildcreatehistoryadapter",level:2},{value:"<code>onCreate</code> (optional)",id:"oncreate-optional",level:3},{value:"<code>getInitialState</code> (optional)",id:"getinitialstate-optional",level:3},{value:"<code>wrapRecipe</code>",id:"wraprecipe",level:3},{value:"<code>applyEntry</code>",id:"applyentry",level:3},{value:"Typescript",id:"typescript",level:2},{value:"Redux methods",id:"redux-methods",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"creating-a-custom-adapter",children:"Creating a Custom Adapter"}),"\n",(0,r.jsxs)(t.p,{children:["While ",(0,r.jsx)(t.code,{children:"createHistoryAdapter"})," and ",(0,r.jsx)(t.code,{children:"createPatchHistoryAdapter"})," cover the most common ways to track history, you may want to create your history entries in a different format. This guide will show you how to create a custom adapter."]}),"\n",(0,r.jsx)(t.h2,{id:"buildcreatehistoryadapter",children:(0,r.jsx)(t.code,{children:"buildCreateHistoryAdapter"})}),"\n",(0,r.jsx)(t.p,{children:"This function allows you to create a custom adapter by providing a custom configuration object with the callbacks required."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const createCustomHistoryAdapter = buildCreateHistoryAdapter({\n  onCreate(config) {\n    // This is called when the adapter is created\n  },\n  wrapRecipe(recipe) {\n    // This is called when a recipe is created\n    return (state, ...args) => {\n      // This is called to update the state\n      recipe(state.present, ...args);\n\n      return entry;\n    };\n  },\n  applyEntry(state, incomingEntry, op) {\n    // This is called to apply a history entry to the state (i.e. undo/redo)\n    return outgoingEntry;\n  },\n});\n"})}),"\n",(0,r.jsxs)(t.h3,{id:"oncreate-optional",children:[(0,r.jsx)(t.code,{children:"onCreate"})," (optional)"]}),"\n",(0,r.jsx)(t.p,{children:"This callback is called when the adapter is created. It receives the configuration object if provided."}),"\n",(0,r.jsxs)(t.p,{children:["This is used by ",(0,r.jsx)(t.code,{children:"createPatchHistoryAdapter"})," to enable patches in Immer."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const onCreate = () => {\n  enablePatches();\n};\n"})}),"\n",(0,r.jsxs)(t.h3,{id:"getinitialstate-optional",children:[(0,r.jsx)(t.code,{children:"getInitialState"})," (optional)"]}),"\n",(0,r.jsx)(t.p,{children:"If you want to manage more properties than in the default state, you can provide a function that returns the initial state."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:'const getCustomInitialState = (data) => {\n  return {\n    ...getInitialState(data),\n    extra: "extra",\n  };\n};\n'})}),"\n",(0,r.jsx)(t.h3,{id:"wraprecipe",children:(0,r.jsx)(t.code,{children:"wrapRecipe"})}),"\n",(0,r.jsx)(t.p,{children:"This callback receives a recipe that operates on the state should return a function that receives the entire history state shape, updates it, and returns a history entry to be added to the past stack."}),"\n",(0,r.jsxs)(t.p,{children:["For example, the ",(0,r.jsx)(t.code,{children:"createHistoryAdapter"})," does a simple write to ",(0,r.jsx)(t.code,{children:"state.present"})," and returns the previous state as the history entry."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const wrapRecipe = (recipe) => {\n  return (state, ...args) => {\n    // get the non-proxy version, so we can return it as the history entry\n    const previousState = ensureCurrent(state.present);\n    // slightly simplified - recipe return behaviour matchers immer\n    state.present = recipe(state.present, ...args);\n    return previousState;\n  };\n};\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"createPatchHistoryAdapter"})," uses Immer's patches to generate a history entry."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const wrapRecipe = (recipe) => {\n  return (state, ...args) => {\n    const [{ present }, redo, undo] = produceWithPatches(state, (draft) => {\n      // slightly simplified - recipe return behaviour matchers immer\n      state.present = recipe(draft, ...args);\n    });\n    state.present = present;\n\n    return { undo, redo };\n  };\n};\n"})}),"\n",(0,r.jsx)(t.h3,{id:"applyentry",children:(0,r.jsx)(t.code,{children:"applyEntry"})}),"\n",(0,r.jsxs)(t.p,{children:["This callback receives the current state, an incoming entry, and an operation (either ",(0,r.jsx)(t.code,{children:"undo"})," or ",(0,r.jsx)(t.code,{children:"redo"}),"). It should return the outgoing entry."]}),"\n",(0,r.jsx)(t.p,{children:"In the context of an undo operation, the incoming entry is the last entry in the past stack, and the outgoing entry is the first entry in the future stack. In the context of a redo operation, the incoming entry is the first entry in the future stack, and the outgoing entry is the last entry in the past stack."}),"\n",(0,r.jsxs)(t.p,{children:["For example, the ",(0,r.jsx)(t.code,{children:"createHistoryAdapter"})," simply swaps the present state with the incoming entry."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const applyEntry = (state, incomingEntry, op) => {\n  const outgoingEntry = state.present;\n  state.present = incomingEntry;\n  return outgoingEntry;\n};\n"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.code,{children:"createPatchHistoryAdapter"})," uses Immer's ",(0,r.jsx)(t.code,{children:"applyPatches"})," to apply the patches to the state, and returns the incoming entry."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const applyEntry = (state, incomingEntry, op) => {\n  applyPatches(state.present, incomingEntry[op]);\n  return incomingEntry;\n};\n"})}),"\n",(0,r.jsx)(t.h2,{id:"typescript",children:"Typescript"}),"\n",(0,r.jsxs)(t.p,{children:["Because the returned ",(0,r.jsx)(t.code,{children:"createCustomHistoryAdapter"})," function is generic, the Typescript needs to be able to act like higher kinded types."]}),"\n",(0,r.jsxs)(t.p,{children:["Inspired by ",(0,r.jsx)(t.a,{href:"https://github.com/gvergnaud/hotscript",children:"HOTScript"}),", this is achieved using an extensible interface."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'export interface BaseHistoryStateFn {\n  data: unknown;\n  state: BaseHistoryState<this["data"], unknown>;\n  config: BaseHistoryAdapterConfig;\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["In order to describe your custom state shape and/or configuration, you should create an extended version of this interface, using ",(0,r.jsx)(t.code,{children:'this["data"]'})," to retrieve the data type."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'interface CustomHistoryState<Data> extends BaseHistoryState<Data, CustomEntry> {\n  extra: string;\n}\n\ninterface CustomConfig extends BaseHistoryAdapterConfig {\n  extraConfig?: string;\n}\n\n// highlight-start\ninterface CustomHistoryStateFn extends BaseHistoryStateFn {\n  state: CustomHistoryState<this["data"]>;\n  config: CustomConfig;\n}\n// highlight-end\n'})}),"\n",(0,r.jsxs)(t.p,{children:["You can then provide this interface to ",(0,r.jsx)(t.code,{children:"buildCreateHistoryAdapter"}),", and all types should infer correctly."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'const createCustomHistoryAdapter =\n  buildCreateHistoryAdapter<CustomHistoryStateFn>({\n    onCreate(config) {\n      console.log(config?.extraConfig); // works\n    },\n    // is required if the default state is not enough\n    getInitialState(data) {\n      return {\n        ...getInitialState(data),\n        extra: "extra",\n      };\n    },\n    wrapRecipe(recipe) {\n      // This is called when a recipe is created\n      return (state, ...args) => {\n        // State is a Draft<CustomHistoryState<Data>>\n\n        return entry; // required to be a CustomEntry\n      };\n    },\n    applyEntry(state, incomingEntry, op) {\n      // State is a Draft<CustomHistoryState<unknown>>\n      // Incoming entry is a CustomEntry\n\n      return outgoingEntry; // required to be a CustomEntry\n    },\n  });\n\nconst exampleAdapter = createCustomHistoryAdapter<CounterState>({\n  extraConfig: "foo",\n});\n// "foo" logged to console\n\nconst initialState = exampleAdapter.getInitialState({ count: 0 });\n//    ^? CustomHistoryState<CounterState>\n'})}),"\n",(0,r.jsxs)(t.admonition,{title:"Constraining the Data Type",type:"tip",children:[(0,r.jsxs)(t.p,{children:["If your custom adapter is only meant to work with a specific data type, you can constrain the ",(0,r.jsx)(t.code,{children:"Data"})," type in the ",(0,r.jsx)(t.code,{children:"CustomHistoryStateFn"})," interface."]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"interface CustomHistoryStateFn extends BaseHistoryStateFn {\n  dataConstraint: Record<string, unknown>;\n  state: CustomHistoryState<Data>;\n  config: CustomConfig;\n}\n"})}),(0,r.jsxs)(t.p,{children:["This will be used to constrain the ",(0,r.jsx)(t.code,{children:"Data"})," type in the ",(0,r.jsx)(t.code,{children:"createCustomHistoryAdapter"})," function."]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"const createCustomHistoryAdapter =\n  //    ^? <Data extends Record<string, unknown>>(config: CustomHistoryAdapterConfig<Data>) => HistoryAdapter<Data, CustomHistoryState<Data>>\n  buildCreateHistoryAdapter<CustomHistoryStateFn>({\n    // ...\n  });\n\n// now errors\nconst exampleAdapter = createCustomHistoryAdapter<number>();\n"})})]}),"\n",(0,r.jsx)(t.h2,{id:"redux-methods",children:"Redux methods"}),"\n",(0,r.jsxs)(t.p,{children:["If you want to include the Redux methods in your custom adapter, this is possible with the ",(0,r.jsx)(t.code,{children:"withRedux"})," enhancer:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'import { withRedux } from "history-adapter/redux";\n\nconst createCustomHistoryAdapter = withRedux(\n  buildCreateHistoryAdapter<CustomHistoryStateFn>({\n    // ...\n  }),\n);\n'})}),"\n",(0,r.jsxs)(t.p,{children:["If you want the raw methods separately, a ",(0,r.jsx)(t.code,{children:"getReduxMethods"})," function is also available."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'import { getReduxMethods } from "history-adapter/redux";\n\nconst reduxMethods = getReduxMethods(counterAdapter);\n'})})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}}}]);